#!/usr/bin/env node
const __DEBUG__=process.env.NODE_DEBUG_LOGGING?true:false;var tty=require("tty");var styles={reset:["0m","0m"],bold:["1m","22m"],dim:["2m","22m"],italic:["3m","23m"],underline:["4m","24m"],inverse:["7m","27m"],black:["30m","39m"],red:["31m","39m"],green:["32m","39m"],yellow:["33m","39m"],blue:["34m","39m"],magenta:["35m","39m"],cyan:["36m","39m"],white:["37m","39m"],default:["39m","39m"],grey:["90m","39m"],brightblack:["01;30m","00;39m"],brightred:["01;31m","00;39m"],brightgreen:["01;32m","00;39m"],brightyellow:["01;33m","00;39m"],brightblue:["01;34m","00;39m"],brightmagenta:["01;35m","00;39m"],brightcyan:["01;36m","00;39m"],brightwhite:["01;37m","00;39m"],brightdefault:["01;39m","00;39m"],brightgrey:["01;90m","00;39m"],bgBlack:["40m","49m"],bgRed:["41m","49m"],bgGreen:["42m","49m"],bgYellow:["43m","49m"],bgBlue:["44m","49m"],bgMagenta:["45m","49m"],bgCyan:["46m","49m"],bgWhite:["47m","49m"],bgDefault:["49m","49m"]};const _c=e=>{return["[",e].join("")};const fmt=(e,t)=>{if(!styles[e]){return t}return[_c(styles[e][0]),t,_c(styles[e][1])].join("")};const print_line=(e,t)=>{console.log([e,t].join("\t"))};const print_item=(e,t,n)=>{const r=n.key_style||"green";const s=n.val_style||"yellow";const o=n.line_maxlen||80;const i=n.key_long||0;const c=n.colspace||" ";const a=n.padstart||" ";const l=i-e.length;const m=c.padEnd(l," ");const p=fmt(r,e);const g=[a,p,m,c].join("");const f=o-g.length;const y=t.slice(0,f+1);const d=fmt(s,y);const u=d;print_line(g,u)};const sort_keys=e=>{var t=999;var n=0;var r=e.sort((function(e,r){if(e[0].length>n){n=e[0].length}if(r[0].length>n){n=r[0].length}if(e[0].length<t){t=e[0].length}if(r[0].length<t){t=r[0].length}return e[0].localeCompare(r[0],{caseFirst:false,numeric:true})}));return{sorted:r,long:n,short:t}};const encoding="utf-8";const print_loop=(e,t)=>{if(!e){return}var n=t.key_style||"brightgreen";var r=t.val_style||"white";var s=" ";var o="  ";var i=process.stdout.columns||80;const c=sort_keys(Object.entries(e));if(c.sorted.length===0){return}var a={line_maxlen:i,key_maxlen:i/2,padstart:o,key_long:c.long,colspace:s,key_style:n,val_style:r};for(var l of c.sorted){print_item(l[0],l[1],a)}return};const get_titleline=e=>{return`--- ${e.toUpperCase()} --- \n`};const print_titleline=e=>{console.log([fmt("cyan",e)].join(""))};const _title=e=>{print_titleline(get_titleline(e))};const print_info=(e,t,n)=>{if(!n){n=Object.assign({},n)}_title(e);print_loop(t,n)};const fs=require("fs"),path=require("path"),{promisify:promisify}=require("util"),fsStat=promisify(fs.stat),fsLStat=promisify(fs.lstat),pAccess=promisify(fs.access),stop=Symbol("findUp.stop"),typeMappings={directory:"isDirectory",file:"isFile"};function checkType({type:e}){if(!(e in typeMappings))throw new Error(`Invalid type specified: ${e}`)}const matchType=(e,t)=>void 0===e||t[typeMappings[e]](),pTry=(e,...t)=>new Promise(n=>{n(e(...t))}),pLimit=e=>{if(!Number.isInteger(e)&&e!==1/0||!(e>0))return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));const t=[];let n=0;const r=()=>{n--,t.length>0&&t.shift()()},s=(e,t,...s)=>{n++;const o=pTry(e,...s);t(o),o.then(r,r)},o=(r,...o)=>new Promise(i=>((r,o,...i)=>{n<e?s(r,o,...i):t.push(s.bind(null,r,o,...i))})(r,i,...o));return Object.defineProperties(o,{activeCount:{get:()=>n},pendingCount:{get:()=>t.length}}),o};class EndError extends Error{constructor(e){super(),this.value=e}}const testElement=async(e,t)=>t(await e),finder=async e=>{const t=await Promise.all(e);if(!0===t[1])throw new EndError(t[0]);return!1},pLocate=async(e,t,n)=>{n={concurrency:1/0,preserveOrder:!0,...n};const r=pLimit(n.concurrency),s=[...e].map(e=>[e,r(testElement,e,t)]),o=pLimit(n.preserveOrder?1:1/0);try{await Promise.all(s.map(e=>o(finder,e)))}catch(e){if(e instanceof EndError)return e.value;throw e}},locatePath=async(e,t)=>{checkType(t={cwd:process.cwd(),type:"file",allowSymlinks:!0,...t});const n=t.allowSymlinks?fsStat:fsLStat;return pLocate(e,async e=>{try{const r=await n(path.resolve(t.cwd,e));return matchType(t.type,r)}catch(e){return!1}},t)},findUp=async(e,t={})=>{let n=path.resolve(t.cwd||"");const{root:r}=path.parse(n),s=[].concat(e),o=async t=>{if("function"!=typeof e)return locatePath(s,t);const n=await e(t.cwd);return"string"==typeof n?locatePath([n],t):n};for(;;){const e=await o({...t,cwd:n});if(e===stop)return;if(e)return path.resolve(n,e);if(n===r)return;n=path.dirname(n)}};const getPkg=async({cwd:e}={})=>findUp("package.json",{cwd:e});function pkgInfo(e,t){const n=["config","depends","env","paths","scripts"];const r="\n\t";const s="Nothing selected. Choose a category to view.";const o=require(`${e}`);if(t&&n.indexOf(t)>=0){switch(t){case"app":print_info(t,o.expo);break;case"config":print_info(t,o.config);break;case"env":print_info(t,process.env);break;case"scripts":print_info(t,o.scripts);break;case"depends":print_info(t,o.dependencies);console.log("");print_info("Dev Dependencies",o.devDependencies);break;case"paths":print_info(t,o.dirs);break;default:console.log([s,"",n.join(r),""].join(r))}}else{console.log([s,"",n.join(r),""].join(r))}}function main(){if(process.stdin.isTTY){process.stdin.setEncoding(encoding);var e=Buffer.from(process.argv[2]||"").toString(encoding);var t=process.argv[2];(async()=>{const e=await getPkg();if(!e){console.log("You are not in an a current npm working directory");process.exit(0)}await pkgInfo(e,t);console.log("Reading From:",e)})()}}main();